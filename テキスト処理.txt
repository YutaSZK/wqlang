# 9/23
テキスト処理 -> 検索エンジン、処理系
  古典的なテキスト検索アルゴリズム
  正規表現
  構文解析系(Parser)
  アプリケーションの実装(言語処理系)

テキスト処理とは
  人間のコミュニケーションツールであるテキストをコンピュータに応用する
  コンピュータからみたテキスト ->
    テキスト: 文字列 = 符号列
    符号(code)
    エディタ
    パーザ
    コンパイラ
    構造を持つテキスト: XML, YAML, JSON, ...

  UNIXの哲学
    flat ASCII files.
    データはテキストファイルに保存せよ(テキスト->テキスト)
      portability, readability, connectivity
      バイナリよりも分かりやすく、人間に処理が理解しやすい
  XML ->
    文書レイアウト情報とテキストデータを持つ
    コンピュータにも人間にも読めるフォーマット

  文字列の照合(string pattern (matching|search))
    検索対象の文字列からパターンを探し出す

  特別に工夫のない、誰にでも思いつく素直なアルゴリズム: 素朴なアルゴリズム(naive algorithm)
    前方一致からの検索(課題)
    対象の長良n, 検索パターンm:
      最悪のオーダー:0(mn)
    !オーダーの記法
      0記法(big-0 notation)

  work00 ->
    素朴なアルゴリズムの実装(言語はなんでもいい)
      regexpクラス禁止、配列と文字列比較での実装

# 9/30
素朴なアルゴリズム
  オーダー
    0(g(n))
    最悪のオーダー: 0(m・n)
  KMPのアルゴリズム: Knuth-Morris-Pratt
    素朴なアルゴリズムでは1文字ずつずらして判定している(毎回ポインタを後戻りしている)
    不一致時の情報を活用し、パターンをずらすことでポインタを後戻りさせないアルゴリズム
      ただしそれでは一致を見逃す場合がある ->
        パターンのある場所で不一致となったとき、部分的に一致する場所があれば後戻りを行う
        どのくらい後戻りするかはパターンのみに依存する
          不一致が発生した場所より前で重なっている個数分後戻りする
        KMP計算をする前に、不一致位置毎の後戻り数を予め宣言しておく
  work01 ->
    KMPを実装
    C言語で実装
    レポートはpdf形式で提出、ソースファイルも提出
    kpm_init, kpm_matchを実装





