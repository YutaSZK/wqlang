# 9/23
テキスト処理 -> 検索エンジン、処理系
  古典的なテキスト検索アルゴリズム
  正規表現
  構文解析系(Parser)
  アプリケーションの実装(言語処理系)

テキスト処理とは
  人間のコミュニケーションツールであるテキストをコンピュータに応用する
  コンピュータからみたテキスト ->
    テキスト: 文字列 = 符号列
    符号(code)
    エディタ
    パーザ
    コンパイラ
    構造を持つテキスト: XML, YAML, JSON, ...

  UNIXの哲学
    flat ASCII files.
    データはテキストファイルに保存せよ(テキスト->テキスト)
      portability, readability, connectivity
      バイナリよりも分かりやすく、人間に処理が理解しやすい
  XML ->
    文書レイアウト情報とテキストデータを持つ
    コンピュータにも人間にも読めるフォーマット

  文字列の照合(string pattern (matching|search))
    検索対象の文字列からパターンを探し出す

  特別に工夫のない、誰にでも思いつく素直なアルゴリズム: 素朴なアルゴリズム(naive algorithm)
    前方一致からの検索(課題)
    対象の長良n, 検索パターンm:
      最悪のオーダー:0(mn)
    !オーダーの記法
      0記法(big-0 notation)

  work00 ->
    素朴なアルゴリズムの実装(言語はなんでもいい)
      regexpクラス禁止、配列と文字列比較での実装

# 9/30
素朴なアルゴリズム
  オーダー
    0(g(n))
    最悪のオーダー: 0(m・n)
  KMPのアルゴリズム: Knuth-Morris-Pratt
    素朴なアルゴリズムでは1文字ずつずらして判定している(毎回ポインタを後戻りしている)
    不一致時の情報を活用し、パターンをずらすことでポインタを後戻りさせないアルゴリズム
      ただしそれでは一致を見逃す場合がある ->
        パターンのある場所で不一致となったとき、部分的に一致する場所があれば後戻りを行う
        どのくらい後戻りするかはパターンのみに依存する
          不一致が発生した場所より前で重なっている個数分後戻りする
        KMP計算をする前に、不一致位置毎の後戻り数を予め宣言しておく
  work01 ->
    KMPを実装
    C言語で実装
    レポートはpdf形式で提出、ソースファイルも提出
    kpm_init, kpm_matchを実装

# 10/7
正規表現(reglar expression)
  ex ->
    abc|def = {abc, def}
    a(b|)c = {abc, ac}
    ab*c = {ac, abc, abbc, abbbc, ...}
  正規表現は文字列の集合を表す
    文字列の集合 = 言語

  基本定義 ->
    文字はその文字自身
    (閉包) p* : pを0回以上繰り返した文字列
    (連結) PQ : PQ文字列
    (選択) P|Q : PまたはQの表す文字列
    (括弧) (P) : Pと同じ文字列(優先順位の定義のみ)
  以上のルールで表現されるもののみが正規表現
  優先順位は閉包、連結、選択の順に強い
    a|bc* = a|b(c*) = {a, b, bc, bcc, ...}
    (a|b)c* = {a, b, ac, bc, acc, ...}

    exercise: a(|b)c* ->
      a(|b)c* = {a, ab, ac, abc, acc, abcc, accc, abccc, acccc, abcccc, ...}

  基本定義を拡張し便利にする ->
    (正閉包) P+ = PP* : 1回以上の繰り返し
    P? = |P : あるかないかの二択
    [0123456789] = 0|1|2|3|4|5|6|7|8|9 : この中の1文字
      1|2|3|4 = [1234] = {1, 2, 3, 4}
    [0-9] = 0|1|2|3|4|5|6|7|8|9
      [a-z]も可
    [^0-9] :[0-9]以外の文字全て

  正規表現の能力
    オートマトンが受理出来る言語と同等の言語を表現できる
      = 正規言語/正則言語
    括弧の入れ子構造は無理

  exercise ->
    1.先頭1文字が大文字で始まる英単語
    2.正負の整数
    3.メールアドレス
    4.{a, aA, aAa, aAaA, ...}
    5.{01, 0011, 000111, 00001111, ...}
    6.偶数個のaの列 = {ε, aa, aaaa, aaaaaa, ...}

egrep
  Unixの標準コマンド
  $ egrep pattern FILE
    マッチする(=正規表現が表す文字列を含む)行を取り出す
  words.txtからa,i,u,e,oの母音をこの順で含む単語を取り出す
    regexp = .*a.*i.*u.*e.*o
    $ egrep a.*i.*u.*e.*o words
  Rubyの正規表現
    標準ライブラリで正規表現を用意している(phpの, python, java等は外部ライブラリ)
    リテラル: /pattern/
      文字列から動的にインスタンス生成: Regexp.compile(pattern_str)
    =~メソッド:
      正規表現 =~ 文字列
      文字列 =~ 正規表現
      マッチしたらindex、マッチしなかったらnilを返す
        閉包はなるべく長くマッチしようとする
        選択は先頭からマッチしようとする

  work02 ->
    egrepを実装
      ARGV、open関数を使用






